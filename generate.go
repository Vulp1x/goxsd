package goxsd

import (
	"bytes"
	"fmt"
	"go/token"
	"go/types"
	"io"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/tools/imports"
)

var (
	// Struct field generated from an element attribute
	// TODO: add omitempty if minOccurences = 0
	attr = "{{ define \"Attr\" }}{{ (lintTitle .Name) }} {{ (lint .Type) }}  `xml:\"{{ .Name }}{{ (omitEmpty .OmitEmpty) }},attr\"`{{ end }}"

	// Struct field generated from an element child element
	child = "{{ define \"Child\" }}{{ (lintTitle .Name) }} {{ if .List }}[]{{ end }}{{ (typeName (fieldType .)) }} `xml:\"{{ .Name }}{{ (omitEmpty .OmitEmpty) }}\"`{{ end }}"

	// Struct field generated from the character data of an element
	cdata = `{{ define "Cdata" }}{{ printf "%s %s ` + "`xml:\\\",cdata\\\"`" + `" (lintTitle .Name) (lint .Type) }}{{ end }}`

	// Struct generated from a non-trivial element (with children and/or attributes)
	// TODO: Add the Annotation comments for both the Structs and Fields.
	elem = `
	// {{ typeName .StructName }} is generated from an XSD element.
	type {{ typeName .StructName }} struct {
		{{- range $a := .Attribs }}
		{{ template "Attr" $a }}{{ end }}
		{{- range $c := .Children }}
		{{ template "Child" $c }}{{ end }}
		{{- if .Cdata }}
		{{ template "Cdata" . }}{{ end -}}
	}
	`
)

var (
	// The initialism pairs are based on the commonInitialisms found in golang/lint
	// https://github.com/golang/lint/blob/4946cea8b6efd778dc31dc2dbeb919535e1b7529/lint.go#L698-L738
	//
	initialismPairs = []string{
		"Api", "API",
		"Ascii", "ASCII",
		"Cpu", "CPU",
		"Css", "CSS",
		"Dns", "DNS",
		"Eof", "EOF",
		"Guid", "GUID",
		"Html", "HTML",
		"Https", "HTTPS",
		"Http", "HTTP",
		"Id", "ID",
		"Ip", "IP",
		"Json", "JSON",
		"Lhs", "LHS",
		"Qps", "QPS",
		"Ram", "RAM",
		"Rhs", "RHS",
		"Rpc", "RPC",
		"Sla", "SLA",
		"Smtp", "SMTP",
		"Sql", "SQL",
		"Ssh", "SSH",
		"Tcp", "TCP",
		"Tls", "TLS",
		"Ttl", "TTL",
		"Udp", "UDP",
		"Uid", "UID",
		"Ui", "UI",
		"Uuid", "UUID",
		"Uri", "URI",
		"Url", "URL",
		"Utf8", "UTF8",
		"Vm", "VM",
		"Xml", "XML",
		"Xsrf", "XSRF",
		"Xss", "XSS",
	}

	initialisms = strings.NewReplacer(initialismPairs...)
)

// Generator is responsible for generating Go structs based on a given XML
// schema tree.
type Generator struct {
	Package    string
	Prefix     string
	Exported   bool
	Translator func(string) string

	types map[string]struct{}
}

func (g Generator) Do(out io.Writer, roots []*xmlTree) error {
	g.types = make(map[string]struct{})

	if g.Translator == nil {
		g.Translator = func(s string) string { return s }
	}

	tt, err := prepareTemplates(g.Prefix, g.Exported, g.Translator)
	if err != nil {
		return fmt.Errorf("could not prepare templates: %s", err)
	}

	var res bytes.Buffer

	if g.Package != "" {
		fmt.Fprintf(&res, `
// generated by goxsd; DO NOT EDIT

package %s

type (
	DateTimeXSDType time.Time
	DateXSDType     time.Time
	TimeXSDType     time.Time
)
`, g.Package)
	}

	for _, e := range roots {
		if err := g.execute(e, tt, &res); err != nil {
			return err
		}
	}

	buf, err := imports.Process("", res.Bytes(), &imports.Options{
		Fragment:  true,
		Comments:  true,
		TabIndent: true,
		TabWidth:  8,
	})
	if err != nil {
		return err
	}

	if _, err := io.Copy(out, bytes.NewBuffer(buf)); err != nil {
		return err
	}

	return nil
}

func (g Generator) execute(root *xmlTree, tt *template.Template, out io.Writer) error {
	root.StructName = root.Type

	if goPrimitiveType(root.Type) {
		root.StructName = root.Name
	}

	if _, ok := g.types[root.StructName]; ok {
		return nil
	}

	if err := tt.Execute(out, root); err != nil {
		return err
	}

	g.types[root.StructName] = struct{}{}

	for _, e := range root.Children {
		if !primitiveType(e) {
			if err := g.execute(e, tt, out); err != nil {
				return err
			}
		}
	}

	return nil
}

func prepareTemplates(prefix string, exported bool, translator func(string) string) (*template.Template, error) {
	typeName := func(name string) string {
		if goPrimitiveType(name) {
			return name
		}

		if prefix != "" {
			name = prefix + strings.Title(name)
		}

		if exported {
			name = strings.Title(name)
		}

		return lint(name, translator)
	}

	omitEmpty := func(empty bool) string {
		if !empty {
			return ""
		}

		return ",omitempty"
	}

	fmap := template.FuncMap{
		"lint":      func(s string) string { return lint(s, translator) },
		"lintTitle": func(s string) string { return lintTitle(s, translator) },
		"typeName":  typeName,
		"fieldType": fieldType,
		"omitEmpty": omitEmpty,
	}

	tt := template.New("yyy").Funcs(fmap)
	if _, err := tt.Parse(attr); err != nil {
		return nil, err
	}
	if _, err := tt.Parse(cdata); err != nil {
		return nil, err
	}
	if _, err := tt.Parse(child); err != nil {
		return nil, err
	}
	if _, err := tt.Parse(elem); err != nil {
		return nil, err
	}
	return tt, nil
}

// If this is a chardata field, the field type must point to a
// struct, even if the element type is a built-in primitive.
func fieldType(e *xmlTree) (res string) {
	if e.Cdata {
		res = e.Name
	} else {
		res = e.Type
	}

	if !e.List && e.OmitEmpty {
		res = "*" + res
	}

	return
}

func omitEmpty(e *xmlTree) string {
	if e.OmitEmpty {
		return ",omitempty"
	}

	return ""
}

func primitiveType(e *xmlTree) bool {
	if e.Cdata {
		return false
	}

	return goPrimitiveType(e.Type)
}

func goPrimitiveType(t string) bool {
	t = strings.Replace(t, "*", "", 1)

	switch t {
	case "bool", "string", "int", "float64", "time.Time", "time.Duration", "DateTimeXSDType", "DateXSDType", "TimeXSDType":
		return true
	}

	return false

}

// lint converts XML identifiers to Go identifiers.
//
// Valid Go Identifiers:
// identifier = letter { letter | unicode_digit }
// See https://golang.org/ref/spec#Identifiers
//
// Valid XML Identifiers:
// See http://www.w3schools.com/xml/xml_elements.asp
//
// XML Naming Rules
// XML elements must follow these naming rules:
//
// Element names are case-sensitive
// Element names must start with a letter or underscore
// Element names cannot start with the letters xml (or XML, or Xml, etc)
// Element names can contain letters, digits, hyphens, underscores, and periods
// Element names cannot contain spaces
// Any name can be used, no words are reserved (except xml).
func lint(str string, translator func(string) string) string {
	if str == "" {
		// FIXME: is this an error? Why was a default type not set earlier?
		return "string"
	}

	// Is the string a Go builtin type?
	// TODO: This is pulling in two packages to check if the type is a Go builtin. Is this necessary?
	if t, _ := types.Eval(token.NewFileSet(), nil, 0, str); t.IsType() {
		return str
	}

	fields := strings.FieldsFunc(str, func(r rune) bool {
		// Underscores are valid characters in Go identifiers, but I have not seen it
		// used often in Go code and without consistency the generated code violates
		// the principle of least astonishment. It is easier to expect all generated
		// code to be in CamelCase instead of a potential mixture of Snake/CamelCase.
		//
		// FIXME: This transformation introduces a higher risk of name collisions.
		// Add a check for name collisions and/or add a predictable rule to resolve
		// name collisions such as appending an incrementing number to the conflicting
		// identifier.
		return r == ' ' || r == '-' || r == '_'
	})

	imported := importedType(str)

	// Convert to Pascal/CamelCase
	for i := range fields {
		if imported && i == 0 {
			continue
		}

		s := strings.Title(fields[i])
		s = initialisms.Replace(s)
		s = translator(s)

		fields[i] = s
	}

	// TODO: if the user has not requested exported types, convert first letter to
	// lowercase.
	// This code is meant to handle unicode, but not all all unicode characters have
	// a lowercase. Use unicode.IsLower() to detect this condition and add a default
	// lowercase prefix such as an ASCII 'x'.
	//r, n := utf8.DecodeRuneInString(fields[0])
	//fields[0] = string(unicode.ToLower(r)) + fields[0][n:]

	return strings.Join(fields, "")
}

func importedType(s string) bool {
	if len(s) < 3 {
		return false
	}

	if strings.ContainsRune(s, ' ') {
		return false
	}

	// Is ASCII.
	for i := 0; i < len(s); i++ {
		if s[i] > unicode.MaxASCII {
			return false
		}
	}

	if s[0] == '.' || s[len(s)-1] == '.' {
		return false
	}

	return strings.Count(s, ".") == 1
}

func lintTitle(s string, translator func(string) string) string {
	return lint(strings.Title(s), translator)
}
